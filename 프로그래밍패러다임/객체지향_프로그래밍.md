# 객체지향 프로그램(OOP, Object Oriented Programming)

- 객체들의 집합으로 프로그램의 상호 작용을 표현

- 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용

<br>

# 객체지향 프로그램의 특징

## 1. 추상화(Abstraction)
- 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것

> 필요로 하는 속성이나 행동을 추출하는 작업

   추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.

   즉, 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것이 추상화다

   ```
   ex. 아우디, BMW, 벤츠는 모두 '자동차'라는 공통점이 있다.
   
   자동차라는 추상화 집합을 만들어두고, 자동차들이 가진 공통적인 특징들을 만들어 활용한다.
   ```

   ***'왜 필요하죠?'***

   예를 들면, '현대'와 같은 다른 자동차 브랜드가 추가될 수도 있다. 이때 추상화로 구현해두면 다른 곳의 코드는 수정할 필요 없이 추가로 만들 부분만 새로 생성해주면 된다.

<br>


## 2. 캡슐화(Encapsulation)
- 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

> 낮은 결합도를 유지할 수 있도록 설계하는 것

   **한 곳에서 변화가 일어나도 다른 곳에 미치는 영향을 최소화 시키는 것**

   (객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것!)

   **결합도(coupling)란, 어떤 기능을 실행할 때 다른 클래스나 모듈에 얼마나 의존적인가를 나타내는 말**

   -> 독립적으로 만들어진 객체들 간의 의존도가 최대한 낮게 만드는 것이 중요하다.

   -> 객체들 간의 의존도가 높아지면 굳이 객체 지향으로 설계하는 의미가 없어진다.

   <br>


   !!***정보 은닉***을 활용!!

   외부에서 접근할 필요가 없는 것들은 private으로 접근하지 못하도록 제한을 두는 것

   (객체안의 필드를 선언할 때 private으로 선언)

    - 위 설명은 JAVA 기준
    - Python은 _(variable) 앞에 _언더바로 private 변수 보통 선언

<br>

## 3. 상속(Inheritance)
- 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장 하는것
- 코드 재사용성 증가

> 일반화 관계(Generalization)라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정



   ### 상속 재사용의 단점

   상속을 통한 재사용을 할 때 나타나는 단점도 존재

   1) 상위 클래스(부모 클래스)의 변경이 어려워진다.

   > 부모 클래스에 의존하는 자식 클래스가 많을 때, 부모 클래스의 변경이 필요하다면?
   >
   > 이를 의존하는 자식 클래스들이 영향을 받게 된다.

   2) 불필요한 클래스가 증가할 수 있다.

   > 유사기능 확장시, 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.

   3) 상속이 잘못 사용될 수 있다.

   > 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다. 상속 받는 클래스가 부모 클래스와 IS-A 관계가 아닐 때 이에 해당한다.

   <br>

   ***해결책은?***

   객체 조립(Composition), 컴포지션이라고 부르기도 한다.

   객체 조립은, **필드에서 다른 객체를 참조하는 방식으로 구현**된다.

   상속에 비해 비교적 런타임 구조가 복잡해지고, 구현이 어려운 단점이 존재하지만 변경 시 유연함을 확보하는데 장점이 매우 크다. 

   따라서 같은 종류가 아닌 클래스를 상속하고 싶을 때는 객체 조립을 우선적으로 적용하는 것이 좋다.

   <br>

   ***그럼 상속은 언제 사용?***

   - IS-A 관계가 성립할 때
   - 재사용 관점이 아닌, 기능의 확장 관점일 때

<br>

## 4. 다형성(Polymorphism)
- 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것
- 오버로딩, 오버라이딩

> 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력

   <br>

  다형성은, 상속과 함께 활용할 때 큰 힘을 발휘

   - **부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것이 다형성**

   - 다형성을 사용하면, 구체적으로 현재 어떤 클래스 객체가 참조되는 지는 무관하게 프로그래밍하는 것이 가능

   - 상속 관계에 있으면, 새로운 자식 클래스가 추가되어도 부모 클래스의 함수를 참조해오면 되기 때문에 다른 클래스는 영향을 받지 않게 됨

<br>

** 오버로딩
- 같은 이름을 가진 메서드를 여러 개 두는 것
- 메서드의 타입, 매개변수의 유형, 개수 등 여러 개 변형 가능
- 컴파일 중에 발생하는 '정적' 다형성

** 오버라이딩
- 주로 메서드 오버라이딩(method overriding)을 말함
- 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것
- 런타임 중에 발생하는 '동적' 다형성

<br>

# 설계 원칙(SOLID)
- 객체지향 프로그래밍 설계 원칙

## 1. 단일 책임 원칙(SRP, Single Responsibility Principle)
- 모든 클래스는 각각 하나의 책임만 가져야 함
- 클래스와 메소드는 하나의 역할만 해야 함

Q. 싱글톤 패턴이 SRP를 어긴다
A. 클래스를 정의하는 부분과 클래스 자체의 기능이 합쳐져 있어서 두 가지 기능을 하기 때문
   원칙을 어긴다는 것을 이해하되, 필요할때 적절히 사용하면 됨

```python
def add(num1, num2):
    return num1 + num2

def numPrint(num):
    print(num)

def addPring(num1, num2):
    num = num1 + num2
    print(num)
    return num


class Cat:
    def __init__(self, age, name):
        self.age = age
        self.name = name
    
    def eat(self, food):
        pass

    def walk(self):
        pass
    
    def speak(self):
        pass

## 원칙 준수하지 않는 코드
    def print(self):
        print(f"age:{self.age} name:{self.name}")

    def log(self, logger):
        logger.log(f"age:{self.age} name:{self.name}")
        logger.log(datetime.now())

## 원칙 준수하는 코드
    def repr(self):
        return f"age:{self.age} name:{self.name}"

kitty = Cat()
print(kitty.repr())
logger.log(kitty.repr())
```


## 2. 개방-폐쇄 원칙(OCP, Open Closed Principle)
- 코드 확장에 대해서는 open, 코드 수정에 대해서는 closed 되어 있어야 함
- 기존 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있도록 설계

```python
##1. 원칙 준수하지 않는 경우
class Animal():
  def __init__(self,type):
    self.type = type


def hey(animal):
  if animal.type == 'Cat':
    print('meow')
  elif animal.type == 'Dog':
    print('bark')

bingo = Animal('Dog')
kitty = Animal('Cat')

#Cow와 Sheep을 추가하기위해 hey함수의 수정이 필요하다.

hey(bingo)
hey(kitty)


##2. 상속을 이용한 Animal class. 추가되는 동물에 대해 hey함수의 수정을 필요로 하지 않는다
class Animal: 
  def speak(self):  #interface method
    pass

class Cat(Animal):
  def speak(self):
    print("meow")

class Dog(Animal):
  def speak(self):
    print("bark")

class Sheep(Animal):
  def speak(self):
    print("meh")

class Cow(Animal):
  def speak(self):
    print("moo")

def hey(animal):
  animal.speak();


bingo = Dog()
kitty = Cat()
sheep = Sheep()
cow = Cow()

hey(bingo)
hey(kitty)
hey(sheep)
hey(cow)


##3. python/javascript같은 언어에서는 Open closed principle을 위해 꼭 상속 개념을 필요로 하지는 않음. (Animal class가 없어도 됨)
class Cat():
  def speak(self):
    print("meow")

class Dog():
  def speak(self):
    print("bark")

def hey(animal):
  animal.speak();

bingo = Dog()
kitty = Cat()

hey(bingo)
hey(kitty)
```


## 3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
- 만약 S가 T의 하위 타입이라면, 프로그램을 변경하지 않고 T타입의 객체를 S타입의 객체로 치환 가능해야 함
- 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가야 함

```python
# LSP를 지키지 못한 예제 1
class Employee:
    """직원 클래스"""
    company_name = "스타커피"
    raise_percentage = 1.02

    def __init__(self, name, wage):
        self.name = name
        self._wage = wage

    def raise_pay(self):
        """직원 시급을 인상하는 메소드"""
        self._wage *= self.raise_percentage

    @property
    def wage(self):
        return self._wage

    def __str__(self):
        """직원 정보를 문자열로 리턴하는 메소드"""
        return Employee.company_name + " 직원: " + self.name


class Cashier(Employee):
    """리스코프 치환 원칙을 지키지 않는 계산대 직원 클래스"""
    coffee_price = 3000

    def __init__(self, name, wage, number_sold=0):
        super().__init__(name, wage)
        self.number_sold = number_sold

    def raise_pay(self, raise_amount):
        """직원 시급을 인상하는 메소드"""
        self.wage += self.raise_amount

    @property
    def wage(self):
        return "시급 정보를 알려줄 수 없습니다"

## Cashier 클래스는 Employee 클래스를 상속
## raise_pay 메소드와 wage라는 getter 메소드를 오버라이딩

# Cashier는 부모 클래스 Employee로부터 raise_pay 메소드를 상속 받을 때 파라미터의 갯수를 추가
# wage 메소드를 상속 받을 때 리턴값의 타입을 바꿈으로써 부모 클래스의 행동 규약을 어겼음
#  -> 리스코프 치환 원칙을 위반


# LSP를 적용한 예제 1
class Cashier(Employee):
    """계산대 직원 클래스"""
    raise_percentage = 1.03
    coffee_price = 3000

    def __init__(self, name, wage, number_sold=0):
        super().__init__(name, wage)
        self.number_sold = number_sold

    def take_order(self, money_received):
        """손님이 낸 돈을 받아 주문 처리를 하고 거스름돈을 리턴한다"""
        if Cashier.coffee_price > money_received:
            print("돈이 충분하지 않습니다. 돈을 다시 계산해서 주세요!")
            return money_received
        else:
            self.number_sold += 1
            change = money_received - Cashier.coffee_price
            return change
            
    def __str__(self):
        return Cashier.company_name + "계산대 직원: " + self.name 

```


## 4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
- 클라이언트는 불필요한 인터페이스에 의존하지 않아야 함
- 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 함

**인터페이스(Interface)**
  - abstract Class와 비슷한 개념


```python
import abc


class Shape(metaclass=abc.ABCMeta):
    """A demo shape class"""

    @abc.abstractmethod
    def draw_circle(self):
        """Draw a circle"""
        raise NotImplemented

    @abc.abstractmethod
    def draw_square(self):
        """ Draw a square"""
        raise NotImplemented


class Circle(Shape):
    """A demo circle class"""

    def draw_circle(self):
        """
        원을 그리는 메서드
        :param  None
        :return: None
        """
        print("원 그리기 !")

    def draw_square(self):
        """
        사각형을 그리는 메서드 사용하지 않음.
        """
        pass


if __name__ == '__main__':
    circle = Circle()
    circle.draw_circle()

## shape라는 인터페이스에, draw_circle, draw_square등 추상적이지 아니한 너무 많은 메서드를 추가함
## 구현체 클래스에서 필요없는 메서드를 다 구현해야 하는 문제
## 리팩토링

import abc


class Shape(metaclass=abc.ABCMeta):
    """A demo shape class"""
    
    @abc.abstractmethod
    def draw(self):
        """Draw a shape"""
        raise NotImplemented


class Circle(Shape):
    """A demo circle class"""

    def draw(self):
        """Draw a circle"""
        pass


class Square(Shape):
    """A demo square class"""

    def draw(self):
        """Draw a square"""
        pass
```


## 5. 의존 역전 원칙(DIP, Dependency Inversion Principle)
- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스에 두어 변하기 쉬운 것에 변화에 영향을 받지 않게 해야 함
- 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립적이어야 함

```python
class Cat:
  def speak(self):
    print("meow")

class Dog:
  def speak(self):
    print("bark")

class Sheep:
  def speak(self):
    pass

....

# Zoo 클래스는 Dog와 Cat의 Dependency가 존재함
# High Level 모듈이 Low Level 모듈을 가지고 있는 일견 논리적 설계
# High Level 모듈에 기능이 추가되고 더 많은 Low Level 모듈이 연결될수록 유지보수가 힘들어짐
class Zoo:
  def __init__(self):
    self.dog = Dog()
    self.cat = Cat()
    self.sheep = Sheep()
    ...

  def speakAll(self):
    self.cat.speak()
    self.dog.speak()


zoo = Zoo()
zoo.speakAll()


### Dependency Inversion Pattern

class Animal: #abstract module
  def speak(self): #interface method
    pass

# Cat과 Dog는 Animal 클래스의 Dependency를 가지게 됨
class Cat(Animal):
  def speak(self):
    print("meow")

class Dog(Animal):
  def speak(self):
    print("bark")


#Zoo depends on Animal.   (Not Cat, Not Dog)
class Zoo:
  def __init__(self):
    self.animals = []

  def addAnimal(self, animal: Aniaml):
    self.animals.append(animal)
  
  def speakAll(self):
    for animal in self.animals:
      animal.speak()

## client 코드
zoo = Zoo()
zoo.addAnimal(Cat())
zoo.addAnimal(Dog())
zoo.speakAll()
              
```


<참고 자료>

코드없는 프로그래밍 YouTube
https://www.youtube.com/playlist?list=PLDV-cCQnUlIZcWXE4PrxJx6U3qKfRTJcK

그림으로 보는 SOLID 원칙
https://blog.siner.io/2020/06/18/solid-principles/

파이썬 클린코드 - 도서
http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791161340463